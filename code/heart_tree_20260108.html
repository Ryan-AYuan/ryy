<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ„›å¿ƒæ¨¹å‹•ç•«</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Playfair+Display:ital@0;1&display=swap');

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #FFF0F5 0%, #E6E6FA 100%); /* Lavender Blush to Lavender gradient */
            overflow: hidden;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }
        #canvas-bg {
            z-index: 0;
        }
        #canvas-tree {
            z-index: 1;
        }
        #canvas-overlay {
            z-index: 2;
            pointer-events: none;
        }

        /* Left Content Area */
        .content-left {
            position: absolute;
            top: 0;
            left: 10%;
            width: 35%; /* Occupy left side */
            height: 100vh; /* Full height */
            z-index: 10; /* Above canvas */
            text-align: left;
            opacity: 0; /* Initially hidden */
            transition: opacity 1s ease-in-out;
            pointer-events: none; /* Let clicks pass through to canvas if needed, but text needs selection? user didn't ask. keeping default interaction for now but ensuring z-index */
            pointer-events: auto;
        }

        .text-wrapper {
            position: absolute;
            top: 40%; /* Move up slightly to leave room for bottom timer */
            transform: translateY(-50%);
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .love-text {
            position: relative;
            width: 100%;
            font-size: 18px;
            line-height: 1.8;
            color: #555;
            font-family: 'KaiTi', 'æ¥·ä½“', serif; 
            background: rgba(255, 255, 255, 0.6);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            min-height: 150px; 
            box-sizing: border-box;
        }
        
        .next-btn {
            margin-top: 15px;
            margin-right: 5px;
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            opacity: 0;
            animation: fadeInBtn 1s forwards 2s, pulseBtn 2s infinite 3s; /* Pulse starts after fade in */
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.4);
        }
        .next-btn:hover {
            transform: scale(1.15) rotate(10deg);
            box-shadow: 0 8px 25px rgba(255, 20, 147, 0.6);
            background: linear-gradient(135deg, #FF1493, #DC143C);
        }

        @keyframes fadeInBtn {
            to { opacity: 1; }
        }
        
        @keyframes pulseBtn {
            0% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(255, 105, 180, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0); }
        }
        
        /* Blinking cursor effect */
        .love-text::after {
            content: '|';
            animation: blink 1s infinite;
            color: #333;
            font-weight: bold;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Timer Styles */
        #timer-container {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%; 
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            display: inline-block; 
            box-sizing: border-box;
        }

        .timer-subtitle {
            font-family: 'Playfair Display', serif;
            font-size: 18px; /* Slightly larger */
            font-style: italic;
            color: #888;
            letter-spacing: 5px; /* Wider spacing */
            margin-bottom: 30px;
            text-transform: uppercase;
        }

        #timer {
            display: flex;
            justify-content: center;
            gap: 30px; /* Larger gap */
        }

        .time-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #timer span {
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            font-size: 68px; /* Larger and more elegant */
            color: #2c3e50; /* Match tree color */
            line-height: 1;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.05);
        }

        .label {
            font-size: 12px; 
            color: #aaa;
            margin-top: 10px;
            font-weight: 400;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Intro Button */
        #intro {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            cursor: pointer;
            z-index: 20;
        }
        .heart-btn {
            font-size: 60px;
            color: #DC143C;
            animation: beat 1s infinite alternate;
            user-select: none;
        }
        .intro-text {
            font-size: 32px;
            color: #FF69B4; /* Hot Pink */
            margin-top: 15px;
            font-family: 'Pacifico', cursive; /* Cuter font */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            animation: float 2s ease-in-out infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        @keyframes beat {
            0% { transform: scale(1); }
            100% { transform: scale(1.2); }
        }
        
        .fade-out {
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease-out;
        }
        .fade-in {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div class="canvas-container">
        <canvas id="canvas-bg"></canvas>
        <canvas id="canvas-tree"></canvas>
        <canvas id="canvas-overlay"></canvas>
    </div>

    <div id="intro" onclick="startAnimation()">
        <div class="heart-btn">â¤ï¸</div>
        <div class="intro-text">ğŸ’— Ryy Baby ğŸ’—</div>
    </div>

    <div class="content-left" id="main-content">
        <div class="text-wrapper">
            <div class="love-text" id="love-text"></div>
            <button id="next-btn" class="next-btn" onclick="nextText()" title="Next">â³</button>
        </div>
        
        <div id="timer-container">
            <div class="timer-subtitle">TOGETHER FOR</div>
            <div id="timer">
                <div class="time-box">
                    <span id="days">0</span>
                    <div class="label">DAYS</div>
                </div>
                <div class="time-box">
                    <span id="hours">0</span>
                    <div class="label">HOURS</div>
                </div>
                <div class="time-box">
                    <span id="minutes">0</span>
                    <div class="label">MINS</div>
                </div>
                <div class="time-box">
                    <span id="seconds">0</span>
                    <div class="label">SECS</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvasBg = document.getElementById('canvas-bg');
        const ctxBg = canvasBg.getContext('2d');
        const canvasTree = document.getElementById('canvas-tree');
        const ctxTree = canvasTree.getContext('2d');
        const canvasOverlay = document.getElementById('canvas-overlay');
        const ctxOverlay = canvasOverlay.getContext('2d');
        
        let width, height;
        let activeBranches = [];
        let activeBlooms = [];
        let floatingHearts = []; // 1. Floating Hearts
        let fireflies = []; // 2. Golden Fireflies
        let snowParticles = []; // 3. Lavender Snow
        let meteors = []; // 4. Pink Meteors
        let mouseTrails = []; // 5. Mouse Trail
        let burstParticles = []; // 6. Click Burst
        let fallingBlooms = []; // 7. Falling Petals from Tree
        let animationRunning = false;
        let mouse = { x: 0, y: 0 };
        let parallax = { x: 0, y: 0 };
        let targetParallax = { x: 0, y: 0 };

        const config = {
            treeColor: "#2c3e50",
            bloomColors: ["#FFC0CB", "#FF69B4", "#FF1493", "#DB7093", "#FF4500", "#FFD700", "#BA55D3", "#9370DB"],
            growSpeed: 3,
            maxBranchDepth: 10, // Reduced from 12 to 10 for performance
        };

        function resize() {
            width = canvasTree.width = canvasOverlay.width = canvasBg.width = window.innerWidth;
            height = canvasTree.height = canvasOverlay.height = canvasBg.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInput(x, y) {
            mouse.x = x;
            mouse.y = y;
            
            // Calculate parallax target (normalized -1 to 1)
            targetParallax.x = (x - width / 2) / (width / 2);
            targetParallax.y = (y - height / 2) / (height / 2);

            if (animationRunning) {
                for (let i = 0; i < 3; i++) {
                    mouseTrails.push(new MouseParticle(mouse.x, mouse.y));
                }
            }
        }

        window.addEventListener('mousemove', (e) => handleInput(e.clientX, e.clientY));
        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        window.addEventListener('click', (e) => {
            if (animationRunning) createBurst(e.clientX, e.clientY);
        });
        window.addEventListener('touchstart', (e) => {
            if (animationRunning) {
                createBurst(e.touches[0].clientX, e.touches[0].clientY);
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            }
        });

        function createBurst(x, y) {
            const count = 30; // Explosion particle count
            for (let i = 0; i < count; i++) {
                burstParticles.push(new BurstParticle(x, y));
            }
        }

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function drawHeart(ctx, x, y, r, color, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -r * 0.4);
            ctx.bezierCurveTo(0, -r * 0.9, -r, -r * 0.9, -r, -r * 0.4);
            ctx.bezierCurveTo(-r, r * 0.5, 0, r, 0, r);
            ctx.bezierCurveTo(0, r, r, r * 0.5, r, -r * 0.4);
            ctx.bezierCurveTo(r, -r * 0.9, 0, -r * 0.9, 0, -r * 0.4);
            ctx.fill();
            ctx.restore();
        }

        // --- Classes ---

        class Branch {
            constructor(x, y, angle, radius, depth) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.radius = radius;
                this.depth = depth;
                this.length = 0;
                this.maxLength = random(100, 150) * Math.pow(0.85, depth);
                if (depth === 0) this.maxLength = 180;
                
                this.speed = config.growSpeed;
                this.growing = true;
                this.split = false;
            }

            grow() {
                if (!this.growing) return;

                const vx = Math.cos(this.angle) * this.speed;
                const vy = Math.sin(this.angle) * this.speed;

                ctxTree.beginPath();
                ctxTree.lineWidth = this.radius;
                ctxTree.lineCap = 'round';
                ctxTree.strokeStyle = config.treeColor;
                ctxTree.moveTo(this.x, this.y);
                
                this.x += vx;
                this.y += vy;
                this.length += this.speed;

                ctxTree.lineTo(this.x, this.y);
                ctxTree.stroke();

                if (this.length >= this.maxLength) {
                    this.growing = false;
                    if (this.depth < config.maxBranchDepth && this.radius > 1) {
                        const numBranches = Math.floor(random(2, 3.2)); // Reduced branching for performance
                        for (let i = 0; i < numBranches; i++) {
                            const newAngle = this.angle + random(-0.85, 0.85);
                            const newRadius = this.radius * 0.72;
                            activeBranches.push(new Branch(this.x, this.y, newAngle, newRadius, this.depth + 1));
                        }
                    } 
                    if (this.depth > 2) {
                        const bloomCount = Math.floor(random(1, 3)); // Reduced count to prevent overcrowding
                        for(let k=0; k<bloomCount; k++) {
                            // Spread blooms wider to fill space without needing more branches
                            activeBlooms.push(new Bloom(this.x + random(-25, 25), this.y + random(-25, 25)));
                        }
                    }
                }
            }
        }

        class Bloom {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.r = 0;
                this.maxR = random(12, 24); // Significantly larger blooms
                this.color = config.bloomColors[Math.floor(random(0, config.bloomColors.length))];
                this.growing = true;
                this.rate = random(0.1, 0.3);
            }

            grow() {
                if (this.growing) {
                    this.r += this.rate;
                    if (this.r >= this.maxR) this.growing = false;
                }
            }
            
            draw(ctx) {
                drawHeart(ctx, this.x, this.y, this.r, this.color);
            }
        }

        // 1. Floating Heart (Rising from bottom)
        class FloatingHeart {
            constructor() {
                this.x = random(0, width);
                this.y = height + 20;
                this.r = random(5, 12);
                this.color = config.bloomColors[Math.floor(random(0, config.bloomColors.length))];
                this.vx = random(-0.5, 0.5);
                this.vy = random(-1, -3); // Rising
                this.alpha = 1;
                this.rotation = random(0, Math.PI*2);
                this.rotSpeed = random(-0.05, 0.05);
            }

            update() {
                this.x += this.vx + Math.sin(this.y * 0.02) * 0.5;
                this.y += this.vy;
                this.rotation += this.rotSpeed;
                if (this.y < -50) this.alpha = 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                drawHeart(ctx, 0, 0, this.r, this.color, this.alpha);
                ctx.restore();
            }
        }

        // 2. Golden Firefly
        class Firefly {
            constructor() {
                this.x = random(0, width);
                this.y = random(0, height);
                this.vx = random(-0.5, 0.5);
                this.vy = random(-0.5, 0.5);
                this.r = random(1, 3);
                this.alpha = random(0, 1);
                this.alphaSpeed = random(0.01, 0.03);
                this.color = "#FFD700"; // Gold
                this.z = random(0.5, 2.0); // Depth factor for parallax
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Wrap around
                if(this.x < -50) this.x = width + 50;
                if(this.x > width + 50) this.x = -50;
                if(this.y < -50) this.y = height + 50;
                if(this.y > height + 50) this.y = -50;

                // Breathing
                this.alpha += this.alphaSpeed;
                if (this.alpha >= 1 || this.alpha <= 0.1) this.alphaSpeed *= -1;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, Math.min(1, this.alpha));
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                // Apply parallax offset based on depth (z)
                let px = this.x + parallax.x * this.z * 20;
                let py = this.y + parallax.y * this.z * 20;
                ctx.arc(px, py, this.r, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
        }

        // 3. Lavender Snow
        class SnowParticle {
            constructor() {
                this.x = random(0, width);
                this.y = random(-height, 0);
                this.vy = random(0.5, 1.5); // Slow fall
                this.r = random(1, 3);
                this.swing = random(0, Math.PI*2);
                this.swingSpeed = random(0.01, 0.03);
                this.color = "rgba(230, 230, 250, 0.8)"; // Lavender
                this.z = random(0.5, 2.0); // Depth factor for parallax
            }

            update() {
                this.y += this.vy;
                this.swing += this.swingSpeed;
                this.x += Math.sin(this.swing) * 0.5;

                if (this.y > height) {
                    this.y = -10;
                    this.x = random(0, width);
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                // Apply parallax offset based on depth (z)
                let px = this.x + parallax.x * this.z * 30;
                let py = this.y + parallax.y * this.z * 30;
                ctx.arc(px, py, this.r, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // 4. Pink Meteor
        class Meteor {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = random(0, width * 2); // Start far right
                this.y = random(-height, height/2);
                this.vx = -random(10, 20); // Fast left
                this.vy = random(5, 10); // Down
                this.len = random(100, 300);
                this.alpha = 0;
                this.active = false;
                this.color = "#FF69B4"; // Pink
            }

            activate() {
                this.active = true;
                this.alpha = 1;
                this.x = random(width/2, width + 500);
                this.y = random(-100, height/3);
            }

            update() {
                if (!this.active) {
                    if (Math.random() < 0.005) this.activate(); // 0.5% chance per frame
                    return;
                }

                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.01;

                if (this.x < -this.len || this.y > height + this.len || this.alpha <= 0) {
                    this.active = false;
                }
            }

            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.vx * 5, this.y - this.vy * 5); // Trail
                ctx.stroke();
                
                // Glowing head
                ctx.fillStyle = "#FFF";
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
        }

        // 5. Mouse Trail
        class MouseParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = random(-2, 2);
                this.vy = random(-2, 2);
                this.life = 1;
                this.decay = random(0.02, 0.05);
                this.color = config.bloomColors[Math.floor(random(0, config.bloomColors.length))];
                this.size = random(2, 5);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= 0.95;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
        }

        // 6. Burst Particle
        class BurstParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = random(0, Math.PI * 2);
                this.speed = random(2, 8); // Fast explosion
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.life = 1;
                this.decay = random(0.015, 0.03);
                this.type = Math.random() > 0.5 ? 'heart' : 'circle';
                this.size = random(5, 12);
                this.color = config.bloomColors[Math.floor(random(0, config.bloomColors.length))];
                this.gravity = 0.15;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
                this.size *= 0.96;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                if (this.type === 'heart') {
                     drawHeart(ctx, this.x, this.y, this.size, this.color, this.life);
                } else {
                     ctx.beginPath();
                     ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                     ctx.fill();
                }
                ctx.restore();
            }
        }

        // 7. Falling Bloom (Petal)
        class FallingBloom {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = random(-1, 1);
                this.vy = random(1, 3);
                this.rotation = random(0, Math.PI * 2);
                this.rotSpeed = random(-0.05, 0.05);
                this.alpha = 1;
            }

            update() {
                this.x += this.vx + Math.sin(this.y * 0.01) * 0.5; // Sway
                this.y += this.vy;
                this.rotation += this.rotSpeed;
                this.alpha -= 0.005; // Slow fade
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                drawHeart(ctx, 0, 0, this.size, this.color, this.alpha);
                ctx.restore();
            }
        }

        function initEffects() {
            // Init Fireflies
            for(let i=0; i<30; i++) fireflies.push(new Firefly());
            
            // Init Snow
            for(let i=0; i<50; i++) snowParticles.push(new SnowParticle());

            // Init Meteors (pool)
            for(let i=0; i<3; i++) meteors.push(new Meteor());
        }

        function initTree() {
            activeBranches = [];
            activeBlooms = [];
            // Start Trunk at 75% width (Right side)
            const trunk = new Branch(width * 0.75, height, -Math.PI / 2, 16, 0);
            activeBranches.push(trunk);
        }

        function loop() {
            if (!animationRunning) return;

            // Smoothly interpolate parallax
            parallax.x += (targetParallax.x - parallax.x) * 0.05;
            parallax.y += (targetParallax.y - parallax.y) * 0.05;

            // Clear Dynamic Canvases
            ctxBg.clearRect(0, 0, width, height);
            ctxOverlay.clearRect(0, 0, width, height);

            // --- Background Effects ---
            
            // Fireflies
            fireflies.forEach(f => { f.update(); f.draw(ctxBg); });
            
            // Snow
            snowParticles.forEach(s => { s.update(); s.draw(ctxBg); });
            
            // Meteors
            meteors.forEach(m => { m.update(); m.draw(ctxBg); });

            // --- Tree Logic ---
            for (let i = activeBranches.length - 1; i >= 0; i--) {
                const b = activeBranches[i];
                b.grow();
                if (!b.growing) activeBranches.splice(i, 1);
            }

            for (let i = activeBlooms.length - 1; i >= 0; i--) {
                const b = activeBlooms[i];
                if (b.growing) {
                    b.grow();
                    b.draw(ctxOverlay);
                    if (!b.growing) {
                        b.draw(ctxTree);
                        activeBlooms.splice(i, 1);
                    }
                }
            }

            // --- Randomly drop petals from the tree ---
            // We need to sample from the static tree canvas? 
            // No, that's hard. Let's keep a separate list of finished blooms or just generate random falling ones near branches?
            // Actually, we lost reference to finished blooms (they are drawn to ctxTree).
            // Better approach: When a bloom finishes growing, we push it to a 'staticBlooms' array instead of just drawing and forgetting,
            // OR just spawn new falling petals from random positions in the canopy.
            // Let's go with spawning random ones near the center/top to simulate falling from tree.
            if (activeBranches.length < 5 && Math.random() < 0.1) { // Only after tree is mostly grown
                // Random position roughly within tree canopy
                const fx = width * 0.75 + random(-300, 300);
                const fy = height/2 + random(-200, 200);
                const color = config.bloomColors[Math.floor(random(0, config.bloomColors.length))];
                fallingBlooms.push(new FallingBloom(fx, fy, color, random(8, 15)));
            }

            // --- Overlay Effects ---

            // Floating Hearts (Rising)
            if (activeBranches.length < 5 && Math.random() < 0.03) {
                floatingHearts.push(new FloatingHeart());
            }

            for (let i = floatingHearts.length - 1; i >= 0; i--) {
                const h = floatingHearts[i];
                h.update();
                if (h.alpha <= 0) floatingHearts.splice(i, 1);
                else h.draw(ctxOverlay);
            }

            // Mouse Trails
            for (let i = mouseTrails.length - 1; i >= 0; i--) {
                const p = mouseTrails[i];
                p.update();
                if (p.life <= 0) mouseTrails.splice(i, 1);
                else p.draw(ctxOverlay);
            }

            // Burst Particles
            for (let i = burstParticles.length - 1; i >= 0; i--) {
                const p = burstParticles[i];
                p.update();
                if (p.life <= 0) burstParticles.splice(i, 1);
                else p.draw(ctxOverlay);
            }

            // Falling Blooms
            for (let i = fallingBlooms.length - 1; i >= 0; i--) {
                const b = fallingBlooms[i];
                b.update();
                if (b.alpha <= 0 || b.y > height) fallingBlooms.splice(i, 1);
                else b.draw(ctxOverlay);
            }

            requestAnimationFrame(loop);
        }

        // Timer: 2025-12-13
        const startDate = new Date("2025-12-13T00:00:00"); 

        const loveTexts = [
            "å¾ˆå¼€å¿ƒæˆ‘ä»¬å‡ºç°åœ¨å½¼æ­¤çš„ç”Ÿå‘½é‡Œï¼Œæˆä¸ºå½¼æ­¤æœ€é‡è¦çš„äººï¼Œæœ€ç¦»ä¸å¼€ä¹Ÿæœ€ä¸æƒ³ç¦»å¼€çš„äººæ˜¯é¦–é€‰ï¼Œæ˜¯ä¾‹å¤–ï¼Œæ˜¯åçˆ±ï¼Œæ˜¯å”¯ä¸€ã€‚æƒ³æˆä¸ºä½ å¼€å¿ƒæ—¶ç¬¬ä¸€ä¸ªæƒ³åˆ†äº«çš„äººï¼Œéš¾è¿‡æ—¶æƒ³ä¾é çš„äººï¼Œæƒ³æˆä¸ºä½ ç”Ÿå‘½ä¸­ä¸å¯ç¼ºå°‘çš„é‚£ä¸€éƒ¨åˆ†ã€‚è™½ç„¶æˆ‘ä¸æ˜¯é‚£ä¸ªæœ€æ¸©æŸ”æœ€å¯çˆ±æœ€æ¼‚äº®çš„å¥³å­©ï¼Œä½†åœ¨ä½ çš„çœ¼é‡Œæˆ‘å´æ˜¯æœ€å¥½çš„å®è´ã€‚ä¸–ç•Œä¸Šæœ€å¹¸ç¦çš„äº‹æƒ…è«è¿‡äºæˆ‘å–œæ¬¢ä½ çš„æ—¶å€™ï¼Œä½ ä¹Ÿå“ˆå·§å–œæ¬¢æˆ‘ï¼Œæˆ‘ä»¬ä¸€èµ·åŒå‘å¥”èµ´ï¼Œç”¨æœ€èˆ’æœçš„æ–¹å¼ç›¸çˆ±ï¼Œæˆ‘ä»¬ä¸€èµ·åŠªåŠ›æˆä¸ºå½¼æ­¤æœ€éœ€è¦çš„äººã€‚",
            "æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œçˆ±å¹¶éåªæœ‰ç”œèœœï¼Œè¿™æ®µæ„Ÿæƒ…æ‰€éœ€çš„ï¼Œè¿˜æœ‰å½¼æ­¤çš„ç†è§£ä¸åŒ…å®¹ã€‚å³ä¾¿æœ‰æ—¶ä½ ä¼šè®©æˆ‘æ„Ÿåˆ°å›°æƒ‘ï¼Œæœ‰æ—¶å› å°äº‹è€Œäº‰åµï¼Œæˆ‘ä¾ç„¶æœŸæœ›ä¸ä½ åˆ†äº«ç”Ÿæ´»çš„ç‚¹æ»´ï¼ŒæœŸå¾…èƒ½ä¸ä½ ç•…èŠå¿ƒä¸­çš„æ¯ä¸ªæƒ³æ³•ã€‚å¦‚æœæˆ‘çš„è„¾æ°”ä¸ä½³ï¼Œæˆ–å› å°äº‹äº‰åµï¼Œè¯·ä½ è®°å¾—ï¼Œè¿™é‡Œç»ä¸æ˜¯ç»“æŸï¼Œè€Œæ˜¯ä¸€ä¸ªæ–°çš„å¼€å§‹ã€‚å¸Œæœ›ä½ èƒ½åŒ…å®¹æˆ‘è¿™é¢—å¤šç–‘ä¸”çˆ±åƒé†‹çš„å¿ƒï¼Œå¤šç»™æˆ‘ä¸€ç‚¹æ—¶é—´ï¼Œä¸€èµ·é¢å¯¹å‰è·¯çš„é£æ™¯ã€‚",
            "æˆ‘æƒ³ä¸ä½ æ¼«æ­¥äºå–§é—¹çš„å¤§è¡—ï¼Œæƒ³è¦ç´§ç´§æ¡ä½ä½ çš„æ‰‹ï¼Œæ„Ÿå—é‚£ä»½æ¸©æš–ã€‚æˆ‘æƒ³åœ¨ä½ æ€€é‡Œå…¥ç¡ï¼Œæµ‘èº«æ˜¯ä½ èº«ä¸Šä¸“å±çš„æ°”æ¯ï¼Œæ¸©æŸ”è€Œå®‰å¿ƒã€‚åœ¨è¿™ä¸ªå¿«èŠ‚å¥çš„ç”Ÿæ´»é‡Œï¼Œé‡è§ä½ å®åœ¨ä¸æ˜“ï¼Œæˆ‘å”¯æå¤±å»ï¼Œä¹Ÿæ·±çŸ¥çæƒœçš„é‡è¦ã€‚æ¯ä¸€å¥æœŸç›¼ï¼Œéƒ½æ»¡å«ç€æˆ‘å¯¹ä½ çš„æ·±æƒ…â€”â€”å¸Œæœ›ä¸ä½ å…±åº¦æ¯ä¸€ä¸ªæ™¨æ˜ï¼Œæ— è®ºæ—¶å…‰å¦‚ä½•å˜è¿ï¼Œæˆ‘ä¾ç„¶æ„¿æ„åœ¨å²æœˆçš„é•¿æ²³ä¸­ï¼Œæ¶æ‰“å‡ºå±äºæˆ‘ä»¬çš„å›å¿†ã€‚"
        ];
        
        let currentTextIndex = 0;
        let typingTimeout = null;

        function typeWriter(text, elementId, speed) {
            let i = 0;
            const element = document.getElementById(elementId);
            element.innerHTML = "";
            if (typingTimeout) clearTimeout(typingTimeout);
            
            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    typingTimeout = setTimeout(type, speed);
                }
            }
            type();
        }

        function nextText() {
            currentTextIndex = (currentTextIndex + 1) % loveTexts.length;
            typeWriter(loveTexts[currentTextIndex], 'love-text', 50);
        }

        function updateTimer() {
            const now = new Date();
            const diff = now - startDate;
            
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            document.getElementById("days").innerText = days;
            document.getElementById("hours").innerText = hours;
            document.getElementById("minutes").innerText = minutes;
            document.getElementById("seconds").innerText = seconds;
        }

        function startAnimation() {
            document.getElementById('intro').classList.add('fade-out');
            
            setTimeout(() => {
                document.getElementById('intro').style.display = 'none';
                const mainContent = document.getElementById('main-content');
                mainContent.classList.add('fade-in');
                
                // Start typing after fade-in is mostly complete
                setTimeout(() => {
                    typeWriter(loveTexts[0], 'love-text', 50); 
                }, 500); 
            }, 800);

            animationRunning = true;
            initEffects(); // Init Background Effects
            initTree();
            loop();
            
            setInterval(updateTimer, 1000);
            updateTimer();
        }
    </script>
</body>
</html>